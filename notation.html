<!-- notation.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grand Staff - MIDI Controlled (Whole Notes)</title>
<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<style>
  body {
    margin: 0;
    background: black;
    color: white;
    font-family: Arial, sans-serif;
  }
  #controls {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10;
  }
  button {
    margin-right: 10px;
    background: #222;
    color: white;
    border: 1px solid #555;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
  }
  #notation {
    display: block;
    margin: 0 auto;
    position: relative;
    top: -5px;
    left: -25%;
    transform: scale(0.88);
    transform-origin: top left;
    width: 900px;
    height: auto;
  }
</style>
</head>
<body>
<div id="controls" style="display: none;">
  <button id="midiBtn">Enable MIDI</button>
  <button id="demoBtn">Demo Chord</button>
  <button id="clearBtn">Clear</button>
</div>

<canvas id="notation" width="900" height="400"></canvas>

<script>
window.addEventListener('load', () => {
  const VF = Vex.Flow;
  const canvas = document.getElementById('notation');
  const renderer = new VF.Renderer(canvas, VF.Renderer.Backends.CANVAS);
  const ctx = renderer.getContext();

  ctx.setFillStyle('black');
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.setStrokeStyle('white');
  ctx.setFillStyle('white');
  ctx.setLineWidth(1.3);

  const staveWidth = 800;

  function drawGrandStaff() {
    ctx.setFillStyle('black');
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.setStrokeStyle('white');
    ctx.setFillStyle('white');

    const treble = new VF.Stave(50, 60, staveWidth);
    const bass = new VF.Stave(50, 200, staveWidth);
    treble.addClef('treble');
    bass.addClef('bass');

    treble.setContext(ctx).draw();
    bass.setContext(ctx).draw();

    const brace = new VF.StaveConnector(treble, bass);
    brace.setType(VF.StaveConnector.type.BRACE);
    brace.setContext(ctx).draw();

    const lineLeft = new VF.StaveConnector(treble, bass);
    lineLeft.setType(VF.StaveConnector.type.SINGLE_LEFT);
    lineLeft.setContext(ctx).draw();

    const lineRight = new VF.StaveConnector(treble, bass);
    lineRight.setType(VF.StaveConnector.type.SINGLE_RIGHT);
    lineRight.setContext(ctx).draw();

    // --- Add note labels in two columns with slight downward offset ---
    ctx.setFont('14px Arial');
    const yOffset = 4;      // shift down
    const labelX = 50 + staveWidth + 10; // column for lines
    const spaceX = labelX + 15;          // column for spaces

    // Treble staff
    const trebleLines = ['F','D','B','G','E']; // top to bottom
    const trebleSpaces = ['E','C','A','F'];    // top to bottom
    trebleLines.forEach((label, i) => {
      ctx.fillText(label, labelX, treble.getYForLine(i) + yOffset);
    });
    trebleSpaces.forEach((label, i) => {
      const y = (treble.getYForLine(i) + treble.getYForLine(i+1)) / 2 + yOffset;
      ctx.fillText(label, spaceX, y);
    });

    // Bass staff
    const bassLines = ['A','F','D','B','G']; // top to bottom
    const bassSpaces = ['G','E','C','A'];    // top to bottom
    bassLines.forEach((label, i) => {
      ctx.fillText(label, labelX, bass.getYForLine(i) + yOffset);
    });
    bassSpaces.forEach((label, i) => {
      const y = (bass.getYForLine(i) + bass.getYForLine(i+1)) / 2 + yOffset;
      ctx.fillText(label, spaceX, y);
    });

    return { treble, bass };
  }



  let staves = drawGrandStaff();
  let activeNotes = new Map(); // midi -> vexflow key

  // --- Enhanced function for proper flat naming ---
  function midiToNoteName(midi, preferFlats = true) {
    const sharpNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
    const flatNames  = ['c','db','d','eb','e','f','gb','g','ab','a','bb','b'];
    const octave = Math.floor(midi / 12 - 1);
    const index = midi % 12;
    const name = preferFlats ? flatNames[index] : sharpNames[index];
    return `${name}/${octave}`;
  }

  function clearStaff() {
    activeNotes.clear();
    staves = drawGrandStaff();
  }

  function drawActiveNotes() {
    staves = drawGrandStaff();

    const trebleKeys = [];
    const bassKeys = [];

    for (let note of activeNotes.values()) {
      const octave = parseInt(note.split('/')[1]);
      if (octave >= 4) trebleKeys.push(note);
      else bassKeys.push(note);
    }

    // --- Draw treble notes ---
    if (trebleKeys.length > 0) {
      const trebleNote = new VF.StaveNote({
        clef: 'treble',
        keys: trebleKeys,
        duration: 'w'
      });

      trebleKeys.forEach((key, i) => {
        if (key.includes('#') || key.includes('b')) {
          trebleNote.addAccidental(i, new VF.Accidental(key.includes('#') ? '#' : 'b'));
        }
      });

      const voice = new VF.Voice({ num_beats: 1, beat_value: 1 });
      voice.addTickable(trebleNote);
      new VF.Formatter().joinVoices([voice]).format([voice], 400);
      voice.draw(ctx, staves.treble);
    }

    // --- Draw bass notes ---
    if (bassKeys.length > 0) {
      const bassNote = new VF.StaveNote({
        clef: 'bass',
        keys: bassKeys,
        duration: 'w'
      });

      bassKeys.forEach((key, i) => {
        if (key.includes('#') || key.includes('b')) {
          bassNote.addAccidental(i, new VF.Accidental(key.includes('#') ? '#' : 'b'));
        }
      });

      const voice = new VF.Voice({ num_beats: 1, beat_value: 1 });
      voice.addTickable(bassNote);
      new VF.Formatter().joinVoices([voice]).format([voice], 400);
      voice.draw(ctx, staves.bass);
    }
  }

  function enableMIDI() {
    if (!navigator.requestMIDIAccess) {
      alert('MIDI not supported');
      return;
    }
    navigator.requestMIDIAccess().then(midi => {
      for (let input of midi.inputs.values()) {
        input.onmidimessage = msg => {
          const [cmd, note, vel] = msg.data;
          if (cmd === 144 && vel > 0) {
            activeNotes.set(note, midiToNoteName(note));
            drawActiveNotes();
          } else if (cmd === 128 || (cmd === 144 && vel === 0)) {
            activeNotes.delete(note);
            drawActiveNotes();
          }
        };
      }
    });
  }

  document.getElementById('midiBtn').onclick = enableMIDI;
  document.getElementById('clearBtn').onclick = clearStaff;

  document.getElementById('demoBtn').onclick = () => {
    activeNotes.set(61, midiToNoteName(61)); // Db4
    activeNotes.set(64, midiToNoteName(64)); // E4
    activeNotes.set(68, midiToNoteName(68)); // Ab4
    drawActiveNotes();
    setTimeout(() => {
      activeNotes.clear();
      drawActiveNotes();
    }, 1500);
  };
});
</script>

<script>
window.addEventListener('load', () => {
  const VF = Vex.Flow;
  const canvas = document.getElementById('notation');
  const renderer = new VF.Renderer(canvas, VF.Renderer.Backends.CANVAS);
  const ctx = renderer.getContext();

  ctx.setFillStyle('black');
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.setStrokeStyle('white');
  ctx.setFillStyle('white');
  ctx.setLineWidth(1.3);

  const staveWidth = 800;
  let activeNotes = new Map(); // midi -> vexflow key
  let staves;

  function midiToNoteName(midi, preferFlats = true) {
    const sharpNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
    const flatNames  = ['c','db','d','eb','e','f','gb','g','ab','a','bb','b'];
    const octave = Math.floor(midi / 12 - 1);
    const index = midi % 12;
    const name = preferFlats ? flatNames[index] : sharpNames[index];
    return `${name}/${octave}`;
  }

  function drawGrandStaff() {
    ctx.setFillStyle('black');
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.setStrokeStyle('white');
    ctx.setFillStyle('white');

    const treble = new VF.Stave(50, 60, staveWidth);
    const bass = new VF.Stave(50, 200, staveWidth);
    treble.addClef('treble');
    bass.addClef('bass');

    treble.setContext(ctx).draw();
    bass.setContext(ctx).draw();

    const brace = new VF.StaveConnector(treble, bass);
    brace.setType(VF.StaveConnector.type.BRACE);
    brace.setContext(ctx).draw();

    const lineLeft = new VF.StaveConnector(treble, bass);
    lineLeft.setType(VF.StaveConnector.type.SINGLE_LEFT);
    lineLeft.setContext(ctx).draw();

    const lineRight = new VF.StaveConnector(treble, bass);
    lineRight.setType(VF.StaveConnector.type.SINGLE_RIGHT);
    lineRight.setContext(ctx).draw();

    // --- Add note labels in two columns with slight downward offset ---
    ctx.setFont('14px Arial');
    const yOffset = 4;      // shift down
    const labelX = 50 + staveWidth + 10; // column for lines
    const spaceX = labelX + 15;          // column for spaces

    const trebleLines = ['F','D','B','G','E']; 
    const trebleSpaces = ['E','C','A','F'];
    trebleLines.forEach((label,i) => ctx.fillText(label, labelX, treble.getYForLine(i) + yOffset));
    trebleSpaces.forEach((label,i) => ctx.fillText(label, spaceX, (treble.getYForLine(i)+treble.getYForLine(i+1))/2 + yOffset));

    const bassLines = ['A','F','D','B','G'];
    const bassSpaces = ['G','E','C','A'];
    bassLines.forEach((label,i) => ctx.fillText(label, labelX, bass.getYForLine(i) + yOffset));
    bassSpaces.forEach((label,i) => ctx.fillText(label, spaceX, (bass.getYForLine(i)+bass.getYForLine(i+1))/2 + yOffset));

    return { treble, bass };
  }

  staves = drawGrandStaff();

  function drawActiveNotes() {
    staves = drawGrandStaff();

    const trebleKeys = [];
    const bassKeys = [];

    for (let note of activeNotes.values()) {
      const octave = parseInt(note.split('/')[1]);
      if (octave >= 4) trebleKeys.push(note);
      else bassKeys.push(note);
    }

    if (trebleKeys.length > 0) {
      const trebleNote = new VF.StaveNote({ clef: 'treble', keys: trebleKeys, duration: 'w' });
      trebleKeys.forEach((key,i)=>{
        if(key.includes('#')) trebleNote.addModifier(new VF.Accidental('#'),i);
        if(key.includes('b')) trebleNote.addModifier(new VF.Accidental('b'),i);
      });
      const voice = new VF.Voice({ num_beats: 1, beat_value: 1 });
      voice.addTickable(trebleNote);
      new VF.Formatter().joinVoices([voice]).format([voice], 400);
      voice.draw(ctx, staves.treble);
    }

    if (bassKeys.length > 0) {
      const bassNote = new VF.StaveNote({ clef: 'bass', keys: bassKeys, duration: 'w' });
      bassKeys.forEach((key,i)=>{
        if(key.includes('#')) bassNote.addModifier(new VF.Accidental('#'),i);
        if(key.includes('b')) bassNote.addModifier(new VF.Accidental('b'),i);
      });
      const voice = new VF.Voice({ num_beats: 1, beat_value: 1 });
      voice.addTickable(bassNote);
      new VF.Formatter().joinVoices([voice]).format([voice], 400);
      voice.draw(ctx, staves.bass);
    }
  }

  // --- Expose a function to parent iframe ---
  window.drawNotes = function(midiNumbers){
    activeNotes.clear();
    midiNumbers.forEach(n => activeNotes.set(n, midiToNoteName(n)));
    drawActiveNotes();
  };

  // Optionally clear notes from parent
  window.clearNotes = function(){
    activeNotes.clear();
    drawGrandStaff();
  };
});
</script>

</body>
</html>
