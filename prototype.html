<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Musica â€” Unified Prototype (RealPianoLocal + Highlighting)</title>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.7.6/build/opensheetmusicdisplay.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/midiconvert@0.4.0/build/MidiConvert.js"></script>

<style>
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0b0b0b;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  #main{height:calc(100vh - 220px);overflow:auto;padding:16px}
  #controls{display:flex;gap:8px;align-items:center;background:#161618;padding:12px;border-radius:8px}
  button,input,select{padding:8px;border-radius:6px;border:1px solid #222;background:#111;color:#fff;cursor:pointer}
  button:active{transform:translateY(1px)}
  #grandStaffWrap{margin-top:12px;border-radius:8px;overflow:hidden}
  #grandStaff{width:100%;min-height:420px;overflow:hidden;border-radius:6px;background:transparent}
  #pianoDock{position:fixed;left:0;right:0;bottom:0;height:12vh;background:#000;border-top:3px solid #111;display:flex;align-items:center;justify-content:center}
  #pianoCanvas{width:100%;height:100%;display:block;touch-action:none}
  #status{color:#9aa;font-size:13px;margin-left:auto}
  .small{font-size:13px;color:#9aa}
  /* OSMD theme placeholders - JS enforces strongly after render */
  body.dark #grandStaff svg { background:#000 !important; }
  body.dark #grandStaff svg * { fill: #fff !important; stroke: #fff !important; }
  body.dark #grandStaff svg text { fill: #fff !important; }
  body.light #grandStaff svg { background:#fff !important; }
  body.light #grandStaff svg * { fill: #000 !important; stroke: #000 !important; }
  body.light #grandStaff svg text { fill: #000 !important; }
</style>
</head>
<body class="dark">

<div id="main">
  <div id="controls">
    <button id="initMidiBtn">Start MIDI</button>
    <button id="enableMidiOutBtn">Enable MIDI Out</button>

    <label class="small"><input id="reverbCheck" type="checkbox"/> Reverb</label>
    <label class="small"><input id="sustainCheck" type="checkbox"/> Sustain</label>

    <input id="midiFileInput" type="file" accept=".mid,.midi" style="display:none"/>
    <button id="loadMidiBtn">Load MIDI</button>

    <input id="xmlFileInput" type="file" accept=".xml,.musicxml,.mxl" style="display:none"/>
    <button id="loadXmlBtn">Load MusicXML</button>

    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>
    <button id="stopBtn">Stop</button>

    <button id="themeToggle" style="margin-left:8px">Dark Mode</button>

    <div id="status">Ready</div>
  </div>

  <div id="grandStaffWrap">
    <div id="grandStaff"></div>
  </div>
</div>

<div id="pianoDock">
  <canvas id="pianoCanvas" aria-label="88-key piano"></canvas>
</div>

<!-- RealPianoLocal (your project's working engine) -->
<script src="assets/js/real-piano-local.js"></script>

<script>
/* =========================
   Globals & state
   ========================= */
let osmd = null;
let midiOut = null;
let midiJsonGlobal = null;      // parsed MidiConvert result
let scheduledTimers = [];       // playback timers (so we can stop)
let playing = false;
let lastXml = null;
let tempoMul = 1.0;
let currentTheme = 'dark';

/* -------------------------
   Utility: Midi -> MusicXML converter (improved)
   - This is a pragmatic converter for basic playback + notation.
   - Converts MIDI notes into measures in 4/4, with quantization controlled by divisions.
   ------------------------- */
function safeGetBPM(midiJson){
  try{
    if(midiJson.header && midiJson.header.bpm) return midiJson.header.bpm;
    if(midiJson.header && midiJson.header.tempos && midiJson.header.tempos.length>0) return midiJson.header.tempos[0].bpm || 120;
  }catch(e){}
  return 120;
}
function safeGetPPQ(midiJson){
  try{ if(midiJson.header && (midiJson.header.PPQ || midiJson.header.ppq)) return midiJson.header.PPQ || midiJson.header.ppq; }catch(e){}
  return 480;
}
function escapeXml(s){ return s.replace(/[<>&'"]/g, c=> ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":"&apos;",'"':'&quot;'}[c])); }

function buildMusicXMLFromMidi(midiJson){
  // Basic converter: splits into measures (4/4), two parts (treble/bass) by threshold
  const bpm = safeGetBPM(midiJson);
  const secondsPerQuarter = 60 / bpm;
  const divisions = 480; // MusicXML divisions
  const splitThreshold = 60; // midi num threshold for RH/LH split (middle C)
  const allNotes = [];

  midiJson.tracks.forEach((t,ti)=>{
    if(!t.notes) return;
    t.notes.forEach(n=>{
      allNotes.push({
        track: ti,
        midi: n.midi,
        name: n.name,
        time: n.time,      // seconds from start
        duration: n.duration,
        velocity: n.velocity || 0.9,
        octave: n.octave
      });
    });
  });

  if(allNotes.length===0) throw new Error('No note events found in MIDI');

  // group into measures assuming 4/4
  const secondsPerMeasure = secondsPerQuarter * 4;
  const measuresMapTreble = new Map();
  const measuresMapBass = new Map();

  allNotes.forEach(n=>{
    const idx = Math.floor(n.time / secondsPerMeasure);
    if(n.midi > splitThreshold){
      if(!measuresMapTreble.has(idx)) measuresMapTreble.set(idx, []);
      measuresMapTreble.get(idx).push(n);
    } else {
      if(!measuresMapBass.has(idx)) measuresMapBass.set(idx, []);
      measuresMapBass.get(idx).push(n);
    }
  });

  const allIndices = Array.from(new Set([...measuresMapTreble.keys(), ...measuresMapBass.keys()])).sort((a,b)=>a-b);
  if(allIndices.length===0) allIndices.push(0);

  // MusicXML header
  let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
  xml += `<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">\n`;
  xml += `<score-partwise version="3.1">\n  <part-list>\n    <score-part id="P1"><part-name>Treble</part-name></score-part>\n    <score-part id="P2"><part-name>Bass</part-name></score-part>\n  </part-list>\n`;

  // helper to convert midi -> pitch
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  function pitchFromMidi(midi){
    const nm = names[midi % 12];
    const step = nm.replace('#','');
    const alter = nm.includes('#') ? 1 : 0;
    const octave = Math.floor(midi / 12) - 1;
    return { step, alter, octave };
  }

  for(let i=0;i<allIndices.length;i++){
    const mi = allIndices[i];
    // Treble measure
    xml += `  <part id="P1">\n    <measure number="${i+1}">\n`;
    if(i===0){
      xml += `      <attributes>\n        <divisions>${divisions}</divisions>\n        <key><fifths>0</fifths></key>\n        <time><beats>4</beats><beat-type>4</beat-type></time>\n        <clef><sign>G</sign><line>2</line></clef>\n      </attributes>\n`;
    }
    const trebleNotes = measuresMapTreble.get(mi) || [];
    if(trebleNotes.length===0){
      xml += `      <note><rest/><duration>${divisions*4}</duration><type>whole</type></note>\n`;
    } else {
      trebleNotes.sort((a,b)=>a.time-b.time);
      trebleNotes.forEach(n=>{
        const p = pitchFromMidi(n.midi);
        // duration mapped to divisions
        const dur = Math.max(1, Math.round((n.duration / secondsPerQuarter) * divisions));
        xml += `      <note>\n        <pitch>\n          <step>${escapeXml(p.step)}</step>\n          ${p.alter?('<alter>'+p.alter+'</alter>') : ''}\n          <octave>${p.octave}</octave>\n        </pitch>\n        <duration>${dur}</duration>\n        <type>quarter</type>\n      </note>\n`;
      });
    }
    xml += `    </measure>\n  </part>\n`;
    // Bass measure
    xml += `  <part id="P2">\n    <measure number="${i+1}">\n`;
    if(i===0){
      xml += `      <attributes>\n        <divisions>${divisions}</divisions>\n        <key><fifths>0</fifths></key>\n        <time><beats>4</beats><beat-type>4</beat-type></time>\n        <clef><sign>F</sign><line>4</line></clef>\n      </attributes>\n`;
    }
    const bassNotes = measuresMapBass.get(mi) || [];
    if(bassNotes.length===0){
      xml += `      <note><rest/><duration>${divisions*4}</duration><type>whole</type></note>\n`;
    } else {
      bassNotes.sort((a,b)=>a.time-b.time);
      bassNotes.forEach(n=>{
        const p = pitchFromMidi(n.midi);
        const dur = Math.max(1, Math.round((n.duration / secondsPerQuarter) * divisions));
        xml += `      <note>\n        <pitch>\n          <step>${escapeXml(p.step)}</step>\n          ${p.alter?('<alter>'+p.alter+'</alter>') : ''}\n          <octave>${p.octave}</octave>\n        </pitch>\n        <duration>${dur}</duration>\n        <type>quarter</type>\n      </note>\n`;
      });
    }
    xml += `    </measure>\n  </part>\n`;
  }

  xml += `</score-partwise>\n`;
  return xml;
}

/* =========================
   OSMD init, theme enforcer
   ========================= */
function initOSMD(){
  osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('grandStaff', {
    autoResize: true,
    autoOpenUrl: false,
    backend: 'svg'
  });
}
initOSMD();

function enforceOsmdSvgTheme(){
  // force style on all svg children after render
  const wrap = document.getElementById('grandStaff');
  const svg = wrap.querySelector('svg');
  if(!svg) return;
  if(currentTheme === 'dark'){
    svg.style.background = '#000';
    svg.querySelectorAll('*').forEach(el=>{
      try{ el.style.fill = '#fff'; el.style.stroke = '#fff'; el.style.color = '#fff'; }catch(e){}
    });
  } else {
    svg.style.background = '#fff';
    svg.querySelectorAll('*').forEach(el=>{
      try{ el.style.fill = '#000'; el.style.stroke = '#000'; el.style.color = '#000'; }catch(e){}
    });
  }
}

/* =========================
   Piano drawing & mapping
   ========================= */
const PIANO = { FIRST:21, LAST:108, keyMap: {} };

function isWhiteMidi(n){
  const mod = n % 12;
  return [0,2,4,5,7,9,11].includes(mod);
}

function drawPiano(){
  const canvas = document.getElementById('pianoCanvas');
  const ctx = canvas.getContext('2d');
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // background
  ctx.fillStyle = (currentTheme === 'dark') ? '#000' : '#fff';
  ctx.fillRect(0,0,cssW,cssH);

  // white keys (52)
  let whiteCount = 0;
  for(let n=PIANO.FIRST;n<=PIANO.LAST;n++) if(isWhiteMidi(n)) whiteCount++;
  const whiteW = cssW / whiteCount;
  const whiteH = cssH;
  const blackW = whiteW * 0.62;
  const blackH = cssH * 0.62;

  PIANO.keyMap = {};
  let whiteIndex = 0;
  // draw white
  for(let n=PIANO.FIRST;n<=PIANO.LAST;n++){
    if(isWhiteMidi(n)){
      const x = whiteIndex * whiteW;
      ctx.fillStyle = '#fff';
      ctx.fillRect(x,0,whiteW,whiteH);
      ctx.strokeStyle = '#111';
      ctx.strokeRect(x+0.5,0.5,whiteW-1,whiteH-1);
      PIANO.keyMap[n] = { x, w: whiteW, h: whiteH, black: false };
      whiteIndex++;
    }
  }
  // draw black
  for(let n=PIANO.FIRST;n<=PIANO.LAST;n++){
    const mod = n % 12;
    if([1,3,6,8,10].includes(mod)){
      // left white key
      let left = n-1;
      while(left >= PIANO.FIRST && !isWhiteMidi(left)) left--;
      if(PIANO.keyMap[left]){
        const x = PIANO.keyMap[left].x + whiteW - blackW/2;
        ctx.fillStyle = '#000';
        ctx.fillRect(x,0,blackW,blackH);
        PIANO.keyMap[n] = { x, w: blackW, h: blackH, black: true };
      }
    }
  }
}

window.addEventListener('resize', drawPiano);
window.addEventListener('load', drawPiano);

/* Flash / highlight piano key by midi number */
function flashKey(midi){
  const c = document.getElementById('pianoCanvas');
  const ctx = c.getContext('2d');
  const k = PIANO.keyMap[midi];
  if(!k) return;
  if(k.black){
    ctx.fillStyle = '#444';
    ctx.fillRect(k.x,0,k.w,k.h);
  } else {
    ctx.fillStyle = '#ccf';
    ctx.fillRect(k.x,0,k.w,k.h);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(k.x+0.5,0.5,k.w-1,k.h-1);
  }
  setTimeout(drawPiano, 120);
}

/* =========================
   MIDI Device selection (prefer real hardware)
   ========================= */
async function enableMidiOut(){
  try{
    const access = await navigator.requestMIDIAccess({ sysex:true });
    const outs = Array.from(access.outputs.values());
    if(outs.length === 0){ setStatus('No MIDI outputs'); return; }
    const real = outs.filter(o=>{
      const n = (o.name||'').toLowerCase();
      return !(n.includes('through')||n.includes('loopback')||n.includes('virtual')||n.includes('midi-through'));
    });
    midiOut = real.length ? real[0] : outs[0];
    setStatus('MIDI Out: ' + midiOut.name);
    console.log('MIDI Out Enabled:', midiOut.name);
  }catch(e){
    console.error('MIDI out error', e);
    setStatus('MIDI out error');
  }
}

/* =========================
   RealPianoLocal integration
   - expects RealPianoLocal.init() and RealPianoLocal.playNote(noteName, velocity, duration)
   ========================= */
async function initRealPianoLocal(){
  if(window.RealPianoLocal && RealPianoLocal.init){
    try{
      await RealPianoLocal.init({ basePath: 'assets/samples', ext: '.mp3' });
      setStatus('RealPiano ready');
    }catch(e){
      console.error('RealPianoLocal init failed', e);
      setStatus('RealPiano init failed');
    }
  } else {
    console.warn('RealPianoLocal not found');
    setStatus('RealPiano not available');
  }
}

/* midi number -> name (C4 etc) */
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
function midiToName(n){
  const step = NOTE_NAMES[n % 12];
  const octave = Math.floor(n/12) - 1;
  return `${step}${octave}`;
}

/* =========================
   Playback scheduling: use midiJsonGlobal to schedule RealPianoLocal and highlights
   ========================= */
function clearScheduled(){
  scheduledTimers.forEach(t => clearTimeout(t));
  scheduledTimers = [];
  playing = false;
}

function schedulePlayback(){
  if(!midiJsonGlobal) { setStatus('No MIDI loaded'); return; }
  clearScheduled();
  setStatus('Playing...');
  playing = true;

  const bpm = safeGetBPM(midiJsonGlobal);
  const secondsPerQuarter = 60 / bpm;
  // gather note events across all tracks
  const events = [];
  midiJsonGlobal.tracks.forEach((t)=>{
    if(!t.notes) return;
    t.notes.forEach(n=>{
      events.push({
        midi: n.midi,
        time: n.time,       // seconds
        duration: n.duration,
        velocity: n.velocity || 0.9
      });
    });
  });
  events.sort((a,b)=>a.time-b.time);

  const startAt = performance.now() / 1000; // seconds (wall clock)
  const baseTime = events.length ? events[0].time : 0;
  // schedule each event
  events.forEach(ev=>{
    const offsetSec = (ev.time - baseTime) / tempoMul;
    const playTime = startAt + offsetSec;
    const delayMs = Math.max(0, (playTime - (performance.now()/1000))*1000);
    const timer = setTimeout(()=>{
      // sound
      const name = midiToName(ev.midi);
      if(window.RealPianoLocal && RealPianoLocal.isReady && RealPianoLocal.isReady()){
        RealPianoLocal.playNote(name, Math.min(1,ev.velocity), Math.max(0.06, ev.duration));
      }
      // highlight piano key
      flashKey(ev.midi);
      // attempt to move OSMD cursor if available
      try{
        if(osmd && osmd.cursor && typeof osmd.cursor.next === 'function'){
          osmd.cursor.next();
        }
      }catch(e){}
    }, delayMs);
    scheduledTimers.push(timer);
  });

  // schedule ended state
  if(events.length){
    const last = events[events.length-1];
    const totalMs = ((last.time - baseTime) + last.duration) * 1000 / tempoMul;
    const endTimer = setTimeout(()=>{ setStatus('Stopped'); playing=false; }, totalMs + 200);
    scheduledTimers.push(endTimer);
  }
}

/* =========================
   Load MIDI file, convert & render
   ========================= */
async function handleMidiFile(file){
  if(!file) return;
  setStatus('Parsing MIDI: ' + file.name);
  const reader = new FileReader();
  reader.onload = async (ev)=>{
    try{
      const buffer = ev.target.result;
      const midiJson = await MidiConvert.parse(buffer);
      midiJsonGlobal = midiJson;
      setStatus('Converting to MusicXML...');
      const xml = buildMusicXMLFromMidi(midiJson);
      lastXml = xml;
      setStatus('Rendering sheet...');
      await osmd.load(xml);
      await osmd.render();
      setTimeout(enforceOsmdSvgTheme, 60);
      // if osmd cursor available, reset it
      try{ if(osmd.cursor && typeof osmd.cursor.show === 'function'){ osmd.cursor.show(); osmd.cursor.reset(); } }catch(e){}
      setStatus('MIDI loaded & rendered');
    }catch(err){
      console.error('MIDI load error', err);
      setStatus('MIDI load failed: ' + (err.message||err));
    }
  };
  reader.readAsArrayBuffer(file);
}

/* =========================
   MusicXML file loader
   ========================= */
async function handleXmlFile(file){
  if(!file) return;
  setStatus('Loading MusicXML: '+file.name);
  const text = await file.text();
  try{
    await osmd.load(text);
    await osmd.render();
    setTimeout(enforceOsmdSvgTheme,50);
    setStatus('MusicXML loaded');
  }catch(e){
    console.error('OSMD load error', e);
    setStatus('OSMD load failed');
  }
}

/* =========================
   UI wiring
   ========================= */
document.getElementById('loadMidiBtn').addEventListener('click', ()=> document.getElementById('midiFileInput').click());
document.getElementById('midiFileInput').addEventListener('change', (e)=> handleMidiFile(e.target.files[0]));

document.getElementById('loadXmlBtn').addEventListener('click', ()=> document.getElementById('xmlFileInput').click());
document.getElementById('xmlFileInput').addEventListener('change', (e)=> handleXmlFile(e.target.files[0]));

document.getElementById('initMidiBtn').addEventListener('click', async ()=>{
  try{ const acc = await navigator.requestMIDIAccess(); console.log('MIDI Ready', acc); setStatus('MIDI Ready'); }catch(e){ console.error(e); setStatus('MIDI init failed'); }
});

document.getElementById('enableMidiOutBtn').addEventListener('click', ()=> enableMidiOut());

document.getElementById('playBtn').addEventListener('click', ()=> {
  if(playing){ setStatus('Already playing'); return; }
  schedulePlayback();
});

document.getElementById('pauseBtn').addEventListener('click', ()=>{
  // quick pause by clearing scheduled timers (no resume implemented)
  clearScheduled();
  setStatus('Paused');
});

document.getElementById('stopBtn').addEventListener('click', ()=>{
  clearScheduled();
  setStatus('Stopped');
});

document.getElementById('themeToggle').addEventListener('click', async ()=>{
  currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.body.classList.remove('dark','light');
  document.body.classList.add(currentTheme);
  document.getElementById('themeToggle').innerText = currentTheme === 'dark' ? 'Dark Mode' : 'Light Mode';
  if(osmd && osmd.rendered){
    await osmd.render();
    setTimeout(enforceOsmdSvgTheme,40);
  }
  drawPiano();
});

/* initialize RealPianoLocal & MIDI engine on load */
window.addEventListener('load', async ()=>{
  drawPiano();
  // init RealPiano local if available
  try{ await initRealPianoLocal(); }catch(e){ console.warn('RealPiano init problem', e); }
});

/* piano click -> play single note using RealPianoLocal */
document.getElementById('pianoCanvas').addEventListener('pointerdown', (ev)=>{
  const rect = ev.target.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  // check black keys first
  for(let n=PIANO.FIRST;n<=PIANO.LAST;n++){
    const k = PIANO.keyMap[n];
    if(k && k.black){
      if(x>=k.x && x<=k.x+k.w && y>=0 && y<=k.h){
        const name = midiToName(n);
        if(window.RealPianoLocal && RealPianoLocal.isReady && RealPianoLocal.isReady()){
          RealPianoLocal.playNote(name, 0.9, 1.0);
        }
        flashKey(n);
        return;
      }
    }
  }
  // white keys
  for(let n=PIANO.FIRST;n<=PIANO.LAST;n++){
    const k = PIANO.keyMap[n];
    if(k && !k.black){
      if(x>=k.x && x<=k.x+k.w){
        const name = midiToName(n);
        if(window.RealPianoLocal && RealPianoLocal.isReady && RealPianoLocal.isReady()){
          RealPianoLocal.playNote(name, 0.9, 1.0);
        }
        flashKey(n);
        return;
      }
    }
  }
});

/* helper: midi -> C4 style name */
function midiToName(m){
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const step = names[m % 12];
  const oct = Math.floor(m/12)-1;
  return `${step}${oct}`;
}

/* status helper */
function setStatus(s){ const el = document.getElementById('status'); if(el) el.textContent = s; }

</script>
</body>
</html>
