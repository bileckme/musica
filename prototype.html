<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Musica Unified Prototype</title>
<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.7.6/build/opensheetmusicdisplay.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
<script src="https://cdn.jsdelivr.net/npm/midiconvert@0.4.0/build/MidiConvert.js"></script>

<style>
  * {
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  html, body {
    margin: 0;
    padding: 0;
    background: #111;
    color: #fff;
    font-family: Arial, sans-serif;
    overflow-x: hidden;
  }
  #mainContainer {
    position: relative;
    width: 100%;
    height: calc(100vh - 220px);
    overflow-y: auto;
    padding: 20px;
    box-sizing: border-box;
  }
  #controls {
    margin-bottom: 15px;
    background: #222;
    padding: 15px;
    border-radius: 6px;
  }
  button, input[type="checkbox"] {
    margin-right: 10px;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  button { background: #444; color: #fff; }
  #grandStaff {
    background: #fff;
    border-radius: 6px;
    width: 100%;
    min-height: 450px;
    overflow: hidden;
  }
  #pianoContainer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 220px;
    background: #000;
    border-top: 3px solid #333;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #pianoCanvas {
    width: 100%;
    height: 100%;
  }
</style>

<style>
  /* ---- LIGHT MODE ---- */
  body.light {
    background: #f4f4f4;
    color: #111;
  }

  body.light #controls {
    background: #ddd;
  }

  body.light button {
    background: #eee;
    color: #111;
  }

  body.light #grandStaff {
    background: #fff;
    border: 1px solid #ccc;
  }

  body.light #pianoContainer {
    background: #fafafa;
    border-top: 3px solid #bbb;
  }

  /* ---- DARK MODE ---- */
  body.dark {
    background: #111;
    color: #fff;
  }

  body.dark #controls {
    background: #222;
  }

  body.dark button {
    background: #444;
    color: #fff;
  }

  body.dark #grandStaff {
    background: #fff;
    /* staff remains white for readability */
  }

  body.dark #pianoContainer {
    background: #000;
    border-top: 3px solid #333;
  }
</style>

<style>
  /* Default = DARK MODE */
  body.dark #grandStaff {
    background: #000 !important;
  }

  body.dark #grandStaff svg {
      background: #000 !important;
  }
  body.dark #grandStaff svg * {
      fill: #fff !important;
      stroke: #fff !important;
  }
  body.dark #grandStaff svg text {
      fill: #fff !important;
  }
  
  /* LIGHT MODE */
  body.light #grandStaff svg {
      background: #fff !important;
  }
  body.light #grandStaff svg * {
      fill: #000 !important;
      stroke: #000 !important;
  }
  body.light #grandStaff svg text {
      fill: #000 !important;
  }
  </style>  

</head>
<body>

<div id="mainContainer">
  <div id="controls">
    <button id="initBtn">Init MIDI</button>
    <button id="enableMidiOut">Enable MIDI Out</button>

    <label><input type="checkbox" id="reverbCheck" /> Reverb</label>
    <label><input type="checkbox" id="sustainCheck" /> Sustain</label>

    <!-- NEW FILE INPUTS -->
    <input type="file" id="midiFileInput" accept=".mid,.midi" style="display:none;" />
    <button id="loadMidiBtn">Load MIDI</button>

    <input type="file" id="xmlFileInput" accept=".xml,.musicxml,.mxl" style="display:none;" />
    <button id="loadXmlBtn">Load MusicXML</button>

    <button id="exportMidiBtn">Export MIDI</button>

    <button id="themeToggle">Dark Mode</button>

  </div>

  <div id="grandStaff"></div>
</div>

<div id="pianoContainer">
  <canvas id="pianoCanvas"></canvas>
</div>

<script>
let osmd = null;
let midiOut = null;

// ----------------------
// PIANO DRAWING FUNCTION (CORRECT 88-KEY LAYOUT)
// ----------------------
function drawPiano() {
    const canvas = document.getElementById("pianoCanvas");
    const ctx = canvas.getContext("2d");

    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    // MIDI note numbers for a full piano: A0 (21) to C8 (108)
    const FIRST_MIDI = 21;
    const LAST_MIDI = 108;
    const totalKeys = LAST_MIDI - FIRST_MIDI + 1;

    // Determine white keys for spacing
    const isWhite = (note) => {
        const mod = note % 12;
        return [0, 2, 4, 5, 7, 9, 11].includes(mod);
    };

    // Count white keys first
    let whiteKeys = 0;
    for (let n = FIRST_MIDI; n <= LAST_MIDI; n++) {
        if (isWhite(n)) whiteKeys++;
    }

    const whiteKeyWidth = canvas.width / whiteKeys;
    const whiteKeyHeight = canvas.height;
    const blackKeyWidth = whiteKeyWidth * 0.6;
    const blackKeyHeight = canvas.height * 0.6;

    // Track X position of white keys
    let whiteIndex = 0;
    const whiteKeyX = {}; // store white key positions so black keys align

    // --- Draw white keys ---
    for (let n = FIRST_MIDI; n <= LAST_MIDI; n++) {
        if (isWhite(n)) {
            const x = whiteIndex * whiteKeyWidth;
            whiteKeyX[n] = x;

            ctx.fillStyle = "#fff";
            ctx.fillRect(x, 0, whiteKeyWidth, whiteKeyHeight);

            ctx.strokeStyle = "#000";
            ctx.strokeRect(x, 0, whiteKeyWidth, whiteKeyHeight);

            whiteIndex++;
        }
    }

    // --- Draw black keys ---
    for (let n = FIRST_MIDI; n <= LAST_MIDI; n++) {
        const mod = n % 12;

        // Black key if note == C#, D#, F#, G#, A#
        if ([1, 3, 6, 8, 10].includes(mod)) {
            // The black key sits between two white keys, usually above the left one
            const leftWhite = n - 1;
            if (whiteKeyX[leftWhite] !== undefined) {
                const x = whiteKeyX[leftWhite] + whiteKeyWidth - blackKeyWidth / 2;

                ctx.fillStyle = "#000";
                ctx.fillRect(x, 0, blackKeyWidth, blackKeyHeight);
            }
        }
    }
}

window.addEventListener("load", () => {
    drawPiano();
    window.addEventListener("resize", drawPiano);
});

// ----------------------
// OSMD + MIDI SETUP
// ----------------------
window.addEventListener("DOMContentLoaded", () => {
    osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("grandStaff", {
        autoResize: true,
        autoOpenUrl: false
    });

    // ----------------------
    // Load MIDI FILE
    // ----------------------
    document.getElementById("loadMidiBtn").addEventListener("click", () => {
        document.getElementById("midiFileInput").click();
    });

    document.getElementById("midiFileInput").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        console.log("Loaded MIDI file:", file.name);
        // Placeholder – MIDI-to-MusicXML conversion required
    });

    // ----------------------
    // Load MUSICXML FILE
    // ----------------------
    document.getElementById("loadXmlBtn").addEventListener("click", () => {
        document.getElementById("xmlFileInput").click();
    });

    document.getElementById("xmlFileInput").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const text = await file.text();

        try {
            await osmd.load(text);
            osmd.render();
        } catch (err) {
            console.error("OSMD Load Error", err);
        }
    });

    // MIDI INIT
    document.getElementById("initBtn").addEventListener("click", async () => {
        try {
            const access = await navigator.requestMIDIAccess();
            console.log("MIDI Ready", access);
        } catch (err) {
            console.error("MIDI Error", err);
        }
    });

    document.getElementById("enableMidiOut").addEventListener("click", async () => {
      const access = await navigator.requestMIDIAccess({ sysex: true });
      const outputs = [...access.outputs.values()];

      if (outputs.length === 0) {
          console.warn("No MIDI devices detected.");
          return;
      }

      // Filter out virtual/dummy devices
      const realDevices = outputs.filter(o =>
          !o.name.toLowerCase().includes("through") &&
          !o.name.toLowerCase().includes("loopback") &&
          !o.name.toLowerCase().includes("virtual")
      );

      // Pick real device if available
      midiOut = realDevices.length > 0 ? realDevices[0] : outputs[0];

      console.log("MIDI Out Enabled:", midiOut.name);
  });

});

// UI: DARK MODE TOGGLING
// ----------------------
// THEME TOGGLING
// ----------------------
let currentTheme = "dark"; 
document.body.classList.add("dark");

document.getElementById("themeToggle").addEventListener("click", async () => {

    // Switch themes
    currentTheme = currentTheme === "dark" ? "light" : "dark";
    document.body.classList.remove("dark", "light");
    document.body.classList.add(currentTheme);

    // Button label
    document.getElementById("themeToggle").innerText =
        currentTheme === "dark" ? "Dark Mode" : "Light Mode";

    // Force OSMD to repaint the SVG so new CSS applies cleanly
    if (osmd && osmd.rendered) {
        await osmd.render();
    }

    drawPiano(); // redraw keys if needed
});

function midiToMusicXML(midi) {
    const divisions = 480; // internal resolution
    const QUARTER = midi.header.ppq;

    // Create measures
    const track = midi.tracks[0];
    const notes = track.notes;

    // group notes by measure
    let measures = {};
    notes.forEach(n => {
        const measureIndex = Math.floor(n.time / (4 * (60 / midi.header.tempos[0].bpm)));
        if (!measures[measureIndex]) measures[measureIndex] = [];
        measures[measureIndex].push(n);
    });

    let xml = `
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC
"-//Recordare//DTD MusicXML 3.1 Partwise//EN"
"http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <part-list>
    <score-part id="P1"><part-name>Music</part-name></score-part>
  </part-list>
  <part id="P1">`;

    const totalMeasures = Object.keys(measures).length;

    for (let m = 0; m < totalMeasures; m++) {
        const measureNotes = measures[m] || [];

        xml += `
    <measure number="${m + 1}">
      <attributes>
        <divisions>${divisions}</divisions>
        <key><fifths>0</fifths></key>
        <time><beats>4</beats><beat-type>4</beat-type></time>
        <clef><sign>G</sign><line>2</line></clef>
      </attributes>`;

        measureNotes.forEach(note => {
            const step = note.name[0];
            const alter = note.name.includes("#") ? 1 : 0;
            const octave = note.octave;

            const xmlDuration = Math.round((note.duration / (60 / midi.header.tempos[0].bpm)) * divisions);

            xml += `
      <note>
        <pitch>
          <step>${step}</step>
          ${alter !== 0 ? `<alter>${alter}</alter>` : ""}
          <octave>${octave}</octave>
        </pitch>
        <duration>${xmlDuration}</duration>
        <type>quarter</type>
      </note>`;
        });

        xml += `
    </measure>`;
    }

    xml += `
  </part>
</score-partwise>`;

    return xml;
}



document.getElementById("midiFileInput").addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    console.log("Loaded MIDI:", file.name);

    const reader = new FileReader();
    reader.onload = async (event) => {
        const midiArrayBuffer = event.target.result;

        const midiJson = await MidiConvert.parse(midiArrayBuffer);
        console.log("MIDI JSON:", midiJson);

        // Convert MIDI → MusicXML
        const xml = midiToMusicXML(midiJson);

        // Feed into OSMD
        try {
            await osmd.load(xml);
            osmd.render();
        } catch (err) {
            console.error("MusicXML Render Error:", err);
        }
    };

    reader.readAsArrayBuffer(file);
});

</script>

</body>
</html>
