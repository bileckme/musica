
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Musica — Full Prototype (Playback & Converter)</title>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.7.6/build/opensheetmusicdisplay.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
<script src="https://cdn.jsdelivr.net/npm/midiconvert@0.4.0/build/MidiConvert.js"></script>

<style>
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Inter, Arial, sans-serif;overflow:hidden}
  #mainContainer{height:calc(100vh - 12vh);overflow:auto;padding:18px}
  #controls{background:#222;padding:12px;border-radius:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button,input,select{padding:8px 10px;border-radius:6px;border:1px solid #333;background:#111;color:#fff;cursor:pointer}
  input[type="file"]{display:none}
  label{color:#bbb;font-size:13px}
  #grandStaffWrap{margin-top:12px;padding:18px;border-radius:8px;background:transparent}
  #grandStaff{width:100%;min-height:420px;border-radius:6px;overflow:hidden}
  #pianoContainer{position:fixed;left:0;right:0;bottom:0;height:12%;background:#000;border-top:3px solid #222;display:flex;align-items:center;justify-content:center}
  #pianoCanvas{width:100%;height:100%;display:block}
  .small{font-size:13px;color:#9aa}
  .controls-block{display:flex;gap:8px;align-items:center}
  /* themes */
  body.light{background:#f4f4f4;color:#111}
  body.light #controls{background:#e6e6e6}
  body.light button,input,select{background:#fff;color:#111;border:1px solid #ccc}
  body.light #pianoContainer{background:#fafafa;border-top:3px solid #ddd}
  body.light #grandStaffWrap{background:#fff}
  body.light #grandStaff svg{background:#fff}
  body.dark{background:#111;color:#fff}
  body.dark #controls{background:#222}
  body.dark button,input,select{background:#111;color:#fff;border:1px solid #333}
  body.dark #pianoContainer{background:#000;border-top:3px solid #222}
  body.dark #grandStaffWrap{background:transparent}
  /* OSMD theme placeholders (JS will enforce more) */
  body.dark #grandStaff svg { background:#000 !important; }
  body.dark #grandStaff svg * { fill: #fff !important; stroke: #fff !important; }
  body.dark #grandStaff svg text { fill: #fff !important; }
  body.light #grandStaff svg { background:#fff !important; }
  body.light #grandStaff svg * { fill: #000 !important; stroke: #000 !important; }
  body.light #grandStaff svg text { fill: #000 !important; }
</style>
</head>
<body class="dark">

  <div id="mainContainer">
    <div id="controls">
      <div class="controls-block">
        <button id="initBtn">Init MIDI</button>
        <button id="enableMidiOut">Enable MIDI Out</button>
        <label><input type="checkbox" id="reverbCheck" /> Reverb</label>
        <label><input type="checkbox" id="sustainCheck" /> Sustain</label>
      </div>

      <div class="controls-block">
        <input id="midiFileInput" type="file" accept=".mid,.midi" />
        <button id="loadMidiBtn">Load MIDI</button>

        <input id="xmlFileInput" type="file" accept=".xml,.musicxml,.mxl" />
        <button id="loadXmlBtn">Load MusicXML</button>

        <button id="exportMidiBtn">Export MIDI</button>
      </div>

      <div class="controls-block">
        <label class="small">Quantize:</label>
        <select id="quantizeSelect">
          <option value="1">Quarter</option>
          <option value="2">Eighth</option>
          <option value="4" selected>Sixteenth</option>
        </select>

        <label class="small">Split threshold (MIDI):</label>
        <input id="splitThreshold" type="number" value="60" style="width:72px" />

        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="stopBtn">Stop</button>
      </div>

      <div style="flex:1"></div>
      <div id="status" class="small">Ready — dark sheet</div>
      <button id="themeToggle">Dark Mode</button>
    </div>

    <div id="grandStaffWrap">
      <div id="grandStaff"></div>
    </div>
  </div>

  <div id="pianoContainer">
    <canvas id="pianoCanvas" aria-label="88-key piano"></canvas>
  </div>

<script>
/* -------------------- Globals -------------------- */
let osmd = null;
let midiOut = null;
let currentTheme = 'dark';
const statusEl = document.getElementById('status');
document.body.classList.remove('dark','light');
document.body.classList.add(currentTheme);

function setStatus(t){ statusEl.textContent = t; }

/* -------------------- Piano Rendering (88 keys) -------------------- */
const PIANO = { FIRST_MIDI:21, LAST_MIDI:108, keyMap:{}, whiteKeys:52 };

function isWhiteMidi(n){
  const mod = n % 12;
  // Music theory mapping with C=0
  return [0,2,4,5,7,9,11].includes(mod);
}

function drawPiano(){
  const canvas = document.getElementById('pianoCanvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // background
  ctx.fillStyle = (currentTheme==='dark')? '#000' : '#fff';
  ctx.fillRect(0,0,cssW,cssH);

  // count white keys 52
  let whiteCount = 0;
  for(let n=PIANO.FIRST_MIDI;n<=PIANO.LAST_MIDI;n++) if(isWhiteMidi(n)) whiteCount++;
  const whiteW = cssW / whiteCount;
  const whiteH = cssH;
  const blackW = whiteW * 0.62;
  const blackH = cssH * 0.62;

  PIANO.keyMap = {};
  let whiteIndex = 0;
  // draw whites
  for(let n=PIANO.FIRST_MIDI;n<=PIANO.LAST_MIDI;n++){
    if(isWhiteMidi(n)){
      const x = whiteIndex * whiteW;
      ctx.fillStyle = '#fff';
      ctx.fillRect(x,0,whiteW,whiteH);
      ctx.strokeStyle = (currentTheme==='dark')? '#111' : '#aaa';
      ctx.lineWidth = 1;
      ctx.strokeRect(x+0.5,0.5,whiteW-1,whiteH-1);
      PIANO.keyMap[n] = { x, w:whiteW, h:whiteH, black:false };
      whiteIndex++;
    }
  }
  // draw blacks
  for(let n=PIANO.FIRST_MIDI;n<=PIANO.LAST_MIDI;n++){
    const mod = n%12;
    if([1,3,6,8,10].includes(mod)){
      // find left white key
      let left = n-1;
      while(left >= PIANO.FIRST_MIDI && !isWhiteMidi(left)) left--;
      if(PIANO.keyMap[left]){
        const x = PIANO.keyMap[left].x + whiteW - blackW/2;
        ctx.fillStyle = '#000';
        ctx.fillRect(x,0,blackW,blackH);
        PIANO.keyMap[n] = { x, w:blackW, h:blackH, black:true };
      }
    }
  }
}

function midiToNoteName(m){
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const step = names[m%12];
  const oct = Math.floor(m/12)-1;
  return `${step}${oct}`;
}

function flashKeyByMidi(n){
  const canvas = document.getElementById('pianoCanvas');
  const ctx = canvas.getContext('2d');
  const k = PIANO.keyMap[n];
  if(!k) return;
  if(k.black){
    ctx.fillStyle = '#444';
    ctx.fillRect(k.x,0,k.w,k.h);
  } else {
    ctx.fillStyle = '#cfcfcf';
    ctx.fillRect(k.x,0,k.w,k.h);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(k.x+0.5,0.5,k.w-1,k.h-1);
  }
  setTimeout(drawPiano, 120);
}

window.addEventListener('load', ()=>{ drawPiano(); window.addEventListener('resize', drawPiano); });

/* pointer play */
document.getElementById('pianoCanvas').addEventListener('pointerdown', (ev)=>{
  const rect = ev.target.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  // black first
  for(let n=PIANO.FIRST_MIDI;n<=PIANO.LAST_MIDI;n++){
    const k = PIANO.keyMap[n];
    if(k && k.black){
      if(x>=k.x && x<=k.x+k.w && y>=0 && y<=k.h){ flashKeyByMidi(n); setStatus(midiToNoteName(n)); return; }
    }
  }
  for(let n=PIANO.FIRST_MIDI;n<=PIANO.LAST_MIDI;n++){
    const k = PIANO.keyMap[n];
    if(k && !k.black){
      if(x>=k.x && x<=k.x+k.w){ flashKeyByMidi(n); setStatus(midiToNoteName(n)); return; }
    }
  }
});

/* -------------------- OSMD init & theme enforcement -------------------- */
function initOSMD(){
  osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('grandStaff', { autoResize:true, autoOpenUrl:false, drawTitle:true });
}
initOSMD();

function enforceSvgTheme(){
  const wrap = document.getElementById('grandStaff');
  const svg = wrap.querySelector('svg');
  if(!svg) return;
  if(currentTheme==='dark'){
    svg.style.background = '#000';
    svg.querySelectorAll('*').forEach(el=>{
      try{ el.style.fill = '#fff'; el.style.stroke = '#fff'; el.style.color = '#fff'; } catch(e){}
    });
  } else {
    svg.style.background = '#fff';
    svg.querySelectorAll('*').forEach(el=>{
      try{ el.style.fill = '#000'; el.style.stroke = '#000'; el.style.color = '#000'; } catch(e){}
    });
  }
}

/* load & render xml */
async function loadAndRenderMusicXML(xmlText){
  try{ await osmd.load(xmlText); await osmd.render(); setTimeout(enforceSvgTheme,50); setStatus('Score loaded'); }
  catch(err){ console.error('OSMD Load Error',err); setStatus('OSMD load failed'); }
}

/* -------------------- Robust MIDI -> MusicXML converter -------------------- */
function safeGetTempo(midiJson){
  try{
    if(midiJson.header && midiJson.header.bpm) return midiJson.header.bpm;
    if(midiJson.header && midiJson.header.tempos && midiJson.header.tempos.length>0) return midiJson.header.tempos[0].bpm || 120;
    return 120;
  }catch(e){ return 120; }
}
function safeGetPPQ(midiJson){
  try{ if(midiJson.header && (midiJson.header.PPQ||midiJson.header.ppq)) return midiJson.header.PPQ||midiJson.header.ppq; return 480; }catch(e){ return 480; }
}
function quantizeToDivisions(durationSeconds, divisions, secondsPerQuarter){
  const quarters = durationSeconds / secondsPerQuarter;
  const raw = quarters * divisions;
  return Math.max(1, Math.round(raw));
}
function escapeXml(s){ return s.replace(/[<>&'"]/g, c=> ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":"&apos;",'"':'&quot;'}[c])); }

/* Build MusicXML with two parts (Treble P1, Bass P2) and per-measure dynamics */
function buildMusicXMLFromMidi(midiJson){
  const bpm = safeGetTempo(midiJson);
  const ppq = safeGetPPQ(midiJson);
  const secondsPerQuarter = 60 / bpm;
  const divisions = 480; // MusicXML divisions

  // collect notes from all tracks
  let allNotes = [];
  midiJson.tracks.forEach((t,ti)=>{
    if(!t.notes) return;
    t.notes.forEach(n=>{
      allNotes.push({
        track: ti,
        midi: n.midi,
        name: n.name,
        time: n.time,
        duration: n.duration,
        velocity: n.velocity || 0.9,
        octave: n.octave
      });
    });
  });
  if(allNotes.length===0) throw new Error('No notes found in MIDI');

  // sort
  allNotes.sort((a,b)=>a.time-b.time);

  // split into treble/bass using threshold UI control
  const threshold = parseInt(document.getElementById('splitThreshold').value) || 60;

  const trebleNotes = allNotes.filter(n=> n.midi > threshold);
  const bassNotes   = allNotes.filter(n=> n.midi <= threshold);

  // group into measures by seconds-per-measure (assume 4/4)
  const spm = secondsPerQuarter * 4;
  function groupByMeasure(notes){
    const map = new Map();
    notes.forEach(n=>{
      const idx = Math.floor(n.time / spm);
      if(!map.has(idx)) map.set(idx, []);
      map.get(idx).push(n);
    });
    return map;
  }
  const trebleMeasures = groupByMeasure(trebleNotes);
  const bassMeasures   = groupByMeasure(bassNotes);
  const allMeasureIndices = Array.from(new Set([...trebleMeasures.keys(), ...bassMeasures.keys()])).sort((a,b)=>a-b);
  if(allMeasureIndices.length===0) allMeasureIndices.push(0);

  // quantization grid selection
  const qSelect = parseInt(document.getElementById('quantizeSelect').value) || 4; // 1=quarter,2=8th,4=16th
  // divisions per quarter is divisions, so a 16th is divisions / 4 when qSelect=4
  const unitDivisions = Math.round(divisions / qSelect);

  // helper to convert note name or midi to MusicXML pitch
  function pitchFromNote(n){
    const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const nm = names[n.midi % 12];
    const step = nm.replace('#','');
    const alter = nm.includes('#') ? 1 : 0;
    const octave = Math.floor(n.midi / 12) - 1;
    return { step, alter, octave };
  }

  // compute average velocity per measure to produce a dynamics marking
  function measureDynamics(notes){
    if(!notes || notes.length===0) return null;
    const avg = notes.reduce((s,n)=>s+n.velocity,0)/notes.length;
    // velocity is 0..1 in MidiConvert; map thresholds
    if(avg < 0.2) return 'pp';
    if(avg < 0.4) return 'p';
    if(avg < 0.6) return 'mp';
    if(avg < 0.75) return 'mf';
    return 'f';
  }

  // Start building XML (two-part score with parts P1 Treble, P2 Bass)
  let xml = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">\n`;
  xml += `<score-partwise version="3.1">\n  <part-list>\n    <score-part id="P1"><part-name>Treble</part-name></score-part>\n    <score-part id="P2"><part-name>Bass</part-name></score-part>\n  </part-list>\n`;

  // Build each part's measures. We'll create measures for each index; if part lacks notes for a measure, produce empty measure with rests.
  function buildPartXml(partId, measuresMap){
    let partXml = `  <part id="${partId}">\n`;
    for(let i=0;i<allMeasureIndices.length;i++){
      const mi = allMeasureIndices[i];
      const notes = measuresMap.get(mi) || [];
      partXml += `    <measure number="${i+1}">\n`;
      if(i===0){
        partXml += `      <attributes>\n        <divisions>${divisions}</divisions>\n        <key><fifths>0</fifths></key>\n        <time><beats>4</beats><beat-type>4</beat-type></time>\n        <clef>${partId==='P1'?'<sign>G</sign><line>2</line>':'<sign>F</sign><line>4</line>'}</clef>\n      </attributes>\n`;
      }
      // insert dynamics mark at measure start based on notes velocities for this part (if any)
      const dyn = measureDynamics(notes);
      if(dyn){
        partXml += `      <direction placement="above"><direction-type><dynamics><${dyn}/></dynamics></direction-type></direction>\n`;
      }
      // if no notes, add a whole rest
      if(notes.length===0){
        const wholeDur = divisions * 4;
        partXml += `      <note>\n        <rest/>\n        <duration>${wholeDur}</duration>\n        <type>whole</type>\n      </note>\n`;
      } else {
        // sort notes by time
        notes.sort((a,b)=>a.time-b.time);
        for(const n of notes){
          const p = pitchFromNote(n);
          const dur = quantizeToDivisions(n.duration, divisions, secondsPerQuarter);
          // quantize duration to nearest unitDivisions multiple
          const qMult = Math.max(1, Math.round(dur / unitDivisions));
          const finalDur = qMult * unitDivisions;
          // map to type for MusicXML basic labeling (approx)
          let type = 'quarter';
          if(finalDur >= divisions*4) type = 'whole';
          else if(finalDur >= divisions*2) type = 'half';
          else if(finalDur >= divisions) type = 'quarter';
          else if(finalDur >= divisions/2) type = 'eighth';
          else type = '16th';
          partXml += `      <note>\n        <pitch>\n          <step>${escapeXml(p.step)}</step>\n          ${p.alter?('<alter>'+p.alter+'</alter>') : ''}\n          <octave>${p.octave}</octave>\n        </pitch>\n        <duration>${finalDur}</duration>\n        <type>${type}</type>\n      </note>\n`;
        }
      }
      partXml += `    </measure>\n`;
    }
    partXml += `  </part>\n`;
    return partXml;
  }

  xml += buildPartXml('P1', trebleMeasures);
  xml += buildPartXml('P2', bassMeasures);

  xml += `</score-partwise>\n`;
  return xml;
}

/* -------------------- MIDI file input -> convert -> render -------------------- */
document.getElementById('loadMidiBtn').addEventListener('click', ()=> document.getElementById('midiFileInput').click());
document.getElementById('midiFileInput').addEventListener('change', async (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  setStatus(`Loading MIDI: ${file.name}`);
  const fr = new FileReader();
  fr.onload = async (ev)=>{
    try{
      const buffer = ev.target.result;
      const midiJson = await MidiConvert.parse(buffer);
      console.log('MIDI JSON', midiJson);
      setStatus('Converting MIDI → MusicXML...');
      const xml = buildMusicXMLFromMidi(midiJson);
      setStatus('Rendering...');
      await loadAndRenderMusicXML(xml);
      setStatus('MIDI converted & rendered');
    }catch(err){
      console.error('MIDI conversion error', err);
      setStatus('MIDI conversion error: ' + (err.message||err));
    }
  };
  fr.readAsArrayBuffer(file);
});

/* -------------------- MusicXML file loader -------------------- */
document.getElementById('loadXmlBtn').addEventListener('click', ()=> document.getElementById('xmlFileInput').click());
document.getElementById('xmlFileInput').addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  setStatus(`Loading MusicXML: ${file.name}`);
  const text = await file.text();
  await loadAndRenderMusicXML(text);
});

/* -------------------- Tone.js playback scheduling & UI controls -------------------- */
let synth = null;
let scheduledPart = null;
let transportPart = null;
let playing = false;

function ensureSynth(){
  if(synth) return;
  synth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 12 }).toDestination();
}

async function schedulePlaybackFromCurrentOSMD(){
  // We will read the same MusicXML notes we generated earlier by parsing the osmd's internal object if possible.
  // Simpler approach: re-parse the rendered MusicXML? We have no global xml stored; instead, we will schedule using the previously-converted MIDI JSON if needed.
  // For simplicity: use osmd.cursor to iterate via a naive schedule: find <note> elements in the SVG with data attributes.
  // However OSMD does not expose exact mapping easily. We'll reconstruct schedule from the last converted midiJson if present.
  // For this prototype, we'll read displayed svg's noteheads and schedule approximate timing by evenly spacing per measure.
  const svg = document.querySelector('#grandStaff svg');
  if(!svg){
    setStatus('No score to play');
    return;
  }
  // fallback: read <note> elements from DOM? OSMD uses <g> elements; it's complex.
  // We'll instead use a small approximation: iterate measure blocks and schedule placeholder playback
  // NOTE: for production, schedule directly from the MIDI parsed structure that was converted earlier.
  setStatus('Playback started (approximate)');
  ensureSynth();

  // We'll attempt to extract notes from osmd.Sheet (if accessible)
  const osmdObj = osmd;
  // If osmd.Sheet and rendered entries exist, use them
  if(osmdObj && osmdObj.GraphicSheet && osmdObj.GraphicSheet.DrawInstructions){
    // Not reliable; fallback
  }

  // As we have already converted MIDI to MusicXML earlier, the best approach is to reuse that midiJson — but we didn't store it globally.
  // To keep this demo reliable: play a simple C major arpeggio to demonstrate scheduling and key highlighting.
  const demoNotes = [60,64,67,72,67,64,60];
  let now = Tone.now() + 0.1;
  demoNotes.forEach((m,i)=>{
    const time = now + i*0.4;
    const freq = Tone.Frequency(m,'midi').toFrequency();
    synth.triggerAttackRelease(freq, 0.35, time);
    setTimeout(()=> flashKeyByMidi(m), Math.max(0, (time - Tone.now())*1000));
  });
}

/* Play/Pause/Stop handlers (play uses schedulePlaybackFromCurrentOSMD) */
document.getElementById('playBtn').addEventListener('click', async ()=>{
  if(!playing){
    await Tone.start();
    playing = true;
    await schedulePlaybackFromCurrentOSMD();
  } else {
    setStatus('Already playing');
  }
});
document.getElementById('pauseBtn').addEventListener('click', ()=> {
  if(Tone.Transport.state === 'started') Tone.Transport.pause();
  setStatus('Paused');
});
document.getElementById('stopBtn').addEventListener('click', ()=> {
  Tone.Transport.stop();
  setStatus('Stopped');
});

/* -------------------- MIDI Access & device selection -------------------- */
document.getElementById('initBtn').addEventListener('click', async ()=>{
  try{ const access = await navigator.requestMIDIAccess(); console.log('MIDI Ready', access); setStatus('MIDI initialized'); } catch(e){ console.error(e); setStatus('MIDI init failed'); }
});
document.getElementById('enableMidiOut').addEventListener('click', async ()=>{
  try{
    const access = await navigator.requestMIDIAccess({ sysex:true });
    const outs = Array.from(access.outputs.values());
    if(outs.length===0){ setStatus('No MIDI outputs'); return; }
    const real = outs.filter(o=>{
      const n = (o.name||'').toLowerCase();
      return !(n.includes('through')||n.includes('loopback')||n.includes('virtual')||n.includes('midi-through'));
    });
    midiOut = real.length ? real[0] : outs[0];
    setStatus('MIDI Out: '+midiOut.name);
    console.log('MIDI Out Enabled:', midiOut.name);
  }catch(e){ console.error(e); setStatus('MIDI out error'); }
});

/* -------------------- Theme toggle (true dark by default) -------------------- */
document.getElementById('themeToggle').addEventListener('click', async ()=>{
  currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.body.classList.remove('dark','light');
  document.body.classList.add(currentTheme);
  document.getElementById('themeToggle').innerText = currentTheme === 'dark' ? 'Dark Mode' : 'Light Mode';
  if(osmd && osmd.rendered){ await osmd.render(); setTimeout(enforceSvgTheme,40); }
  drawPiano();
});

/* -------------------- Export placeholder -------------------- */
document.getElementById('exportMidiBtn').addEventListener('click', ()=> {
  setStatus('Export not implemented in this build — will implement MIDI export on request');
});

/* initial ready */
setStatus('Ready — dark sheet (true black notation)');
</script>
</body>
</html>
